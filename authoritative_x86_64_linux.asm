#                       #
# DO NOT EDIT THIS FILE #
#                       #

###############################################################################
#
# @file authoritative_x86_64_linux.asm
#
# @author Christopher A. Bohn
#
# @brief Implementation of arithmetic authoritative results, written in x86_64
#       assembly for Linux
#
# The code within the functions was hand-written (and is common to all x86_64
#       Unix-like systems); however, the surrounding directives were prepared
#       by a compiler.
#
###############################################################################

#
# IntegerLab (c) 2018-23 Christopher A. Bohn
#
# Starter code licensed under the Apache License, Version 2.0
# (http://www.apache.org/licenses/LICENSE-2.0).
#

#include "authoritative_results.h"

#if defined X86_64_LINUX

	.text
	.file	"authoritative_results.c"
	.globl	evaluate_addition               # -- Begin function evaluate_addition
	.p2align	4, 0x90
	.type	evaluate_addition,@function
evaluate_addition:                      # @evaluate_addition
	.cfi_startproc
# %bb.0:
    addw %si, %di
    setz 4(%rdx)
    sets 5(%rdx)
    seto 6(%rdx)
    setc 7(%rdx)
    movw %di, (%rdx)
	retq
.Lfunc_end0:
	.size	evaluate_addition, .Lfunc_end0-evaluate_addition
	.cfi_endproc
                                        # -- End function
	.globl	evaluate_subtraction            # -- Begin function evaluate_subtraction
	.p2align	4, 0x90
	.type	evaluate_subtraction,@function
evaluate_subtraction:                   # @evaluate_subtraction
	.cfi_startproc
# %bb.0:
    subw %si, %di
    setz 4(%rdx)
    sets 5(%rdx)
    seto 6(%rdx)
    setc 7(%rdx)
    movw %di, (%rdx)
	retq
.Lfunc_end1:
	.size	evaluate_subtraction, .Lfunc_end1-evaluate_subtraction
	.cfi_endproc
                                        # -- End function
	.globl	evaluate_unsigned_multiplication # -- Begin function evaluate_unsigned_multiplication
	.p2align	4, 0x90
	.type	evaluate_unsigned_multiplication,@function
evaluate_unsigned_multiplication:       # @evaluate_unsigned_multiplication
	.cfi_startproc
# %bb.0:
	pushq %rax
	pushq %rdx
	movw %di, %ax
	mulw %si
	movw %dx, %di
	popq %rdx
	setz 4(%rdx)
	sets 5(%rdx)
	seto 6(%rdx)
	setc 7(%rdx)
	movw %ax, (%rdx)
	movw %di, 2(%rdx)
	popq %rax
	retq
.Lfunc_end2:
	.size	evaluate_unsigned_multiplication, .Lfunc_end2-evaluate_unsigned_multiplication
	.cfi_endproc
                                        # -- End function
	.globl	evaluate_unsigned_division      # -- Begin function evaluate_unsigned_division
	.p2align	4, 0x90
	.type	evaluate_unsigned_division,@function
evaluate_unsigned_division:             # @evaluate_unsigned_division
	.cfi_startproc
# %bb.0:
	pushq %rax
	pushq %rdx
	movw %di, %ax
	movw $0, %dx
	divw %si
	movw %dx, %di
	popq %rdx
	setz 4(%rdx)
	sets 5(%rdx)
	seto 6(%rdx)
	setc 7(%rdx)
	movw %ax, (%rdx)
	movw %di, 2(%rdx)
	popq %rax
	retq
.Lfunc_end3:
	.size	evaluate_unsigned_division, .Lfunc_end3-evaluate_unsigned_division
	.cfi_endproc
                                        # -- End function
	.globl	evaluate_signed_multiplication  # -- Begin function evaluate_signed_multiplication
	.p2align	4, 0x90
	.type	evaluate_signed_multiplication,@function
evaluate_signed_multiplication:         # @evaluate_signed_multiplication
	.cfi_startproc
# %bb.0:
	pushq %rax
	pushq %rdx
	movw %di, %ax
	imulw %si
	movw %dx, %di
	popq %rdx
	setz 4(%rdx)
	sets 5(%rdx)
	seto 6(%rdx)
	setc 7(%rdx)
	movw %ax, (%rdx)
	movw %di, 2(%rdx)
	popq %rax
	retq
.Lfunc_end4:
	.size	evaluate_signed_multiplication, .Lfunc_end4-evaluate_signed_multiplication
	.cfi_endproc
                                        # -- End function
	.globl	evaluate_signed_division        # -- Begin function evaluate_signed_division
	.p2align	4, 0x90
	.type	evaluate_signed_division,@function
evaluate_signed_division:               # @evaluate_signed_division
	.cfi_startproc
# %bb.0:
	pushq %rax
	pushq %rdx
	movw %di, %ax
	movw $0, %dx
	testw %ax, %ax
	# cmovs $-1, %rdx
	# the next two instructions substitute for the cmov instruction, which cannot move from immediate to register
	jns .Lcmovsubstitute
	movw $-1, %dx
.Lcmovsubstitute:
	# the previous two instructions substitute for the cmov instruction
	idivw %si
	movw %dx, %di
	popq %rdx
	setz 4(%rdx)
	sets 5(%rdx)
	seto 6(%rdx)
	setc 7(%rdx)
	movw %ax, (%rdx)
	movw %di, 2(%rdx)
	popq %rax
	retq
.Lfunc_end5:
	.size	evaluate_signed_division, .Lfunc_end5-evaluate_signed_division
	.cfi_endproc
                                        # -- End function
	.section	".note.GNU-stack","",@progbits

#endif